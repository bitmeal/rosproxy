# ROSProxy
Transparently proxy ROS communication between different networks -- physical or virtual -- or connect local containers to an external ROS network.

## get it!
### npm
the npm package allows you to run the rosproxy cli as `rosproxy` from everywhere, when installed globally.
```
npm install -g rosproxy
```

### container
get it in a container form *ghcr.io*
```
docker pull ghcr.io/bitmeal/rosproxy
```

## use it
* point the proxy to your ROS master
* configure the proxy `http://<internal_hostname>:<port>/master` as master for nodes to proxy
* ðŸŽ‰


```
rosproxy [options] [port]
```
* `--port/-p` (*default: copied from `$ROS_MASTER_URI`*): management/XMLRPC API port to listen on; must be available on internal (to be proxied) network segment
* `--ros-master-uri/-m` or `$ROS_MASTER_URI`: ROS master address
* `--hostname/-n` or `$ROS_HOSTNAME`/`$ROS_IP` (*default: machines hostname*): hostname to report to all ROS nodes for proxied endpoints; has to be available from the external (to be proxied to) network
* `--port-range/-r` (*default: none/random allocation*): limit all port allocations (except master API) to given range; enables exposing nodes from containers
* `--quiet/-q`: suppress output
* `--debug/-d`: set log level `debug`


## dev
### testing
> âš  Test requires *docker*/*docker-compose* (and *WSL* on Windows)

```bash
npm test
```

Tests use `bats` testing framework. Running `npm test` will take care of most things and report what's missing.
Info and error messages generated by `npm test` may **not** be *TAP* compliant! To ensure machine readable output, init submodules manually and ensure all dependencies to be available.

* Tests are executed in a *docker-compose* setup, recreating a NAT routed setup with internal and external networks.
* Use ASCII collation order `LC_COLLATE=C` when running bats without using `test/test.bash`